***困难点***

1. 缺少临时变量，为什么会出错：
```rust
let r1:&String = "hello".to_string().borrow();
println!("r1: {:p}", &r1);
```
这里to_string() 没有一个临时变量接住，为什么会出错？

2. 所有权移动？ filter里是 |&&car|car...， |car|**car...， |&car|*car...， 会有不同的所有权移动？ 
```rust
let dd = cars
        .iter()
        .filter(|car |{
            let c = *car;  // 这里本来发生了移动，但我没使用，编译器直接忽略了??????
            println!("{:?}", c);
            (**car).id>"2".to_string()
        }).collect::<Vec<_>>();
    println!("dd:{:?}",dd)
```

3. 指针解引用 会发生所有权移动？ 为什么这里会报错？无法移动？ 而 match &*reference 这样又可以呢？&*reference 有发生移动吗？
```rust
match *reference {
        val => println!("Got a value via dereferencing: {:?}", val),
    }
```
4. 一个String类型的value，为什么可以 &*value 这样使用？ 参看`global_static_hashmap.rs` 这个类
```rust
OPERATIONS_MAP.get(&*value)
```
为什么这里可以这样传值？ `let c = *value`, 如果 `*` 等效于 `Deref`，那为什么 `c`的类型是 `str` ？ 通过查看 `impl Deref for String`
它的deref函数这里只能传入&String啊！！ 那这里的 *value就不是 Deref了！ 



















